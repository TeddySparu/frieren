<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frieren & J√§germaister - Ultimate Brawl</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            background: #0a0a14;
            color: #fff;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .hidden { display: none !important; }

        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .screen h1 {
            font-size: 4em;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
            margin-bottom: 30px;
        }
        .screen h2 {
            font-size: 2.5em;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        .screen button {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            padding: 15px 30px;
            border: 3px solid #f0f;
            background: transparent;
            color: #f0f;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px;
            box-shadow: inset 0 0 10px #f0f, 0 0 10px #f0f;
        }
        .screen button:hover {
            background: #f0f;
            color: #0a0a14;
        }

        #character-select { display: flex; gap: 40px; }
        .char-card {
            border: 4px solid #0ff;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .char-card:hover, .char-card.selected {
            transform: scale(1.1);
            background: #0ff;
            color: #0a0a14;
            box-shadow: 0 0 25px #0ff;
        }
        .char-card h3 { font-size: 2em; margin-top: 0; }
        .char-card p { font-size: 4em; margin-bottom: 0; }

        #game-container {
            position: relative;
            border: 4px solid #f0f;
            box-shadow: 0 0 25px #f0f;
        }
        
        canvas {
            display: block;
            background: #1a1a2e;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
        }
        .player-hud {
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 15px;
        }
        .player-hud .stocks { font-size: 2em; }
        .player-hud .damage { font-size: 3em; font-weight: bold; min-width: 120px; text-align: center; }
        #player1-hud { color: #4ddbff; border: 2px solid #4ddbff; }
        #player2-hud { color: #ff9933; border: 2px solid #ff9933; }
    </style>
</head>
<body>

    <div id="loading-screen" class="screen">
        <h1>Chargement...</h1>
    </div>

    <div id="login-screen" class="screen hidden">
        <h1>Ultimate Brawl</h1>
        <p style="font-size: 1.2em;">Veuillez vous connecter via la page principale pour jouer.</p>
        <a href="index.html" style="text-decoration: none;"><button>Retour au Site</button></a>
    </div>

    <div id="char-select-screen" class="screen hidden">
        <h1>Choisissez votre combattant</h1>
        <div id="character-select">
            <div class="char-card" id="char-frieren" onclick="window.game.selectCharacter('frieren')">
                <p>üßô‚Äç‚ôÄÔ∏è</p>
                <h3>Frieren</h3>
            </div>
            <div class="char-card" id="char-jagermeister" onclick="window.game.selectCharacter('jagermeister')">
                <p>ü¶å</p>
                <h3>J√§germaister</h3>
            </div>
        </div>
        <p id="char-select-status" style="font-size: 1.5em;">En attente de votre choix...</p>
    </div>

    <div id="matchmaking-screen" class="screen hidden">
        <h1>Recherche d'un adversaire...</h1>
        <button onclick="window.game.cancelMatchmaking()">Annuler</button>
    </div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="player1-hud" class="player-hud">
                <div class="stocks">P1 ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div class="damage">0%</div>
            </div>
            <div id="player2-hud" class="player-hud">
                <div class="damage">0%</div>
                <div class="stocks">P2 ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
        </div>
    </div>
    
    <div id="game-over-screen" class="screen hidden">
        <h1 id="game-result"></h1>
        <button onclick="window.game.rematch()">Rejouer</button>
        <a href="index.html" style="text-decoration: none;"><button>Menu Principal</button></a>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, onSnapshot, collection, query, where, limit, getDocs, updateDoc, deleteDoc, setDoc, serverTimestamp, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        const firebaseConfig = {
          apiKey: "AIzaSyBhyxeEHBKrhuECJKt2d7NwSN7lcv39IX0",
          authDomain: "frieren-2-79e0c.firebaseapp.com",
          projectId: "frieren-2-79e0c",
          storageBucket: "frieren-2-79e0c.appspot.com",
          messagingSenderId: "861104473745",
          appId: "1:861104473745:web:377da7b0daaf5570572130"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const CHARACTERS = {
            frieren: {
                name: 'Frieren', color: '#4ddbff', emoji: 'üßô‚Äç‚ôÄÔ∏è', size: { w: 40, h: 55 }, weight: 0.9,
                attacks: {
                    quick: { type: 'projectile', hitbox: { w: 20, h: 20 }, damage: 3, knockbackBase: 3, knockbackScale: 0.1, speed: 12, duration: 30, cooldown: 25 },
                    strong: { type: 'beam', hitbox: { w: 150, h: 30 }, damage: 10, knockbackBase: 6, knockbackScale: 0.5, duration: 25, cooldown: 80, startup: 15 }
                }
            },
            jagermeister: {
                name: 'J√§germaister', color: '#ff9933', emoji: 'ü¶å', size: { w: 50, h: 50 }, weight: 1.1,
                attacks: {
                    quick: { type: 'punch', hitbox: { w: 50, h: 30 }, damage: 6, knockbackBase: 5, knockbackScale: 0.4, duration: 10, cooldown: 30, startup: 5 },
                    strong: { type: 'stomp', hitbox: { w: 100, h: 25 }, damage: 14, knockbackBase: 8, knockbackScale: 0.8, duration: 20, cooldown: 100, startup: 20 }
                }
            }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 1200;
                this.canvas.height = 700;
                
                this.GRAVITY = 0.6;
                this.JUMP_FORCE = -15;
                this.PLAYER_SPEED = 6;
                this.FRICTION = 0.85;

                this.state = 'LOADING';
                this.currentUser = null;
                this.currentGameId = null;
                this.gameListener = null;
                this.playerNumber = null;
                
                this.players = {};
                this.platforms = [
                    { x: 200, y: 550, width: 800, height: 30 },
                    { x: 300, y: 400, width: 200, height: 20 },
                    { x: 700, y: 400, width: 200, height: 20 }
                ];
                this.projectiles = [];
                this.particles = [];
                this.keys = {};
                this.animationFrameId = null;

                this.initUI();
                this.authCheck();
            }

            initUI() {
                this.ui = {
                    loading: document.getElementById('loading-screen'),
                    login: document.getElementById('login-screen'),
                    charSelect: document.getElementById('char-select-screen'),
                    charSelectStatus: document.getElementById('char-select-status'),
                    matchmaking: document.getElementById('matchmaking-screen'),
                    game: document.getElementById('game-container'),
                    gameOver: document.getElementById('game-over-screen'),
                    p1Hud: { damage: document.querySelector('#player1-hud .damage'), stocks: document.querySelector('#player1-hud .stocks') },
                    p2Hud: { damage: document.querySelector('#player2-hud .damage'), stocks: document.querySelector('#player2-hud .stocks') },
                    result: document.getElementById('game-result')
                };
            }
            
            setState(newState) {
                this.state = newState;
                Object.values(this.ui).forEach(el => el.classList.add('hidden'));
                switch(newState) {
                    case 'LOADING': this.ui.loading.classList.remove('hidden'); break;
                    case 'LOGIN': this.ui.login.classList.remove('hidden'); break;
                    case 'CHAR_SELECT': this.ui.charSelect.classList.remove('hidden'); break;
                    case 'MATCHMAKING': this.ui.matchmaking.classList.remove('hidden'); break;
                    case 'PLAYING': this.ui.game.classList.remove('hidden'); break;
                    case 'GAMEOVER': this.ui.gameOver.classList.remove('hidden'); break;
                }
            }

            authCheck() {
                onAuthStateChanged(auth, user => {
                    if (user) {
                        this.currentUser = user;
                        this.setState('CHAR_SELECT');
                    } else {
                        this.currentUser = null;
                        this.setState('LOGIN');
                        this.cleanup();
                    }
                });
            }

            async selectCharacter(charId) {
                if (this.state !== 'CHAR_SELECT') return;
                
                document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                document.getElementById(`char-${charId}`).classList.add('selected');
                this.ui.charSelectStatus.textContent = `Vous avez choisi ${CHARACTERS[charId].name}. En attente de l'adversaire...`;

                this.myCharId = charId;
                this.startMatchmaking();
            }

            async startMatchmaking() {
                this.setState('MATCHMAKING');

                const q = query(collection(db, "ultimate-brawl-games"), where("status", "==", "waiting"), limit(1));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const gameDoc = querySnapshot.docs[0];
                    if (gameDoc.data().p1.uid !== this.currentUser.uid) {
                        this.currentGameId = gameDoc.id;
                        this.playerNumber = 2;
                        await updateDoc(doc(db, "ultimate-brawl-games", this.currentGameId), {
                            "p2.uid": this.currentUser.uid,
                            "p2.charId": this.myCharId,
                            status: "playing",
                            lastUpdate: serverTimestamp()
                        });
                        this.listenToGame();
                    }
                } else {
                    const newGameRef = doc(collection(db, "ultimate-brawl-games"));
                    this.currentGameId = newGameRef.id;
                    this.playerNumber = 1;
                    await setDoc(newGameRef, this.getInitialGameState());
                    this.listenToGame();
                }
            }

            getInitialGameState() {
                return {
                    status: "waiting",
                    p1: this.createPlayerState(1, this.currentUser.uid, this.myCharId),
                    p2: this.createPlayerState(2, null, null),
                    lastUpdate: serverTimestamp(),
                    winner: null
                };
            }

            createPlayerState(playerNum, uid, charId) {
                const spawnX = playerNum === 1 ? this.canvas.width / 4 : (this.canvas.width / 4) * 3;
                return {
                    uid: uid,
                    charId: charId,
                    x: spawnX, y: 100, vx: 0, vy: 0,
                    damage: 0, stocks: 3, facing: playerNum === 1 ? 1 : -1,
                    action: 'idle', actionFrame: 0,
                    jumpsLeft: 2, isGrounded: false, invincibleUntil: 0
                };
            }

            listenToGame() {
                if (this.gameListener) this.gameListener();
                this.gameListener = onSnapshot(doc(db, "ultimate-brawl-games", this.currentGameId), (doc) => {
                    if (!doc.exists()) return this.cleanup();
                    
                    const gameState = doc.data();
                    if (gameState.status === 'playing') {
                        if (this.state !== 'PLAYING') this.startGame(gameState);
                        this.players = { p1: new Player(gameState.p1, this), p2: new Player(gameState.p2, this) };
                    }
                    if (gameState.status === 'finished') {
                        this.endGame(gameState.winner);
                    }
                });
            }

            startGame(initialState) {
                this.setState('PLAYING');
                this.players = { p1: new Player(initialState.p1, this), p2: new Player(initialState.p2, this) };
                this.setupKeyboardListeners();
                this.gameLoop();
            }

            gameLoop() {
                this.update();
                this.draw();
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.state !== 'PLAYING' || !this.players.p1 || !this.players.p2) return;
                
                const myPlayer = this.playerNumber === 1 ? this.players.p1 : this.players.p2;
                const opponent = this.playerNumber === 1 ? this.players.p2 : this.players.p1;
                
                // --- CONTR√îLES LOCAUX ---
                myPlayer.handleControls(this.keys);
                
                // --- MISE √Ä JOUR PHYSIQUE ET ACTIONS ---
                Object.values(this.players).forEach(p => p.update());
                
                // --- D√âTECTION DES COLLISIONS D'ATTAQUES ---
                this.checkHitCollisions();
                
                // --- MISE √Ä JOUR DES PROJECTILES ET PARTICULES ---
                this.projectiles = this.projectiles.filter(p => p.update());
                this.particles = this.particles.filter(p => p.update());
                
                // --- ENVOI DE L'√âTAT LOCAL √Ä FIREBASE ---
                this.sendStateToFirestore(myPlayer);
            }

            checkHitCollisions() {
                const p1 = this.players.p1;
                const p2 = this.players.p2;

                if (p1.hitbox && p1.isHittable(p2) && p1.hitbox.collidesWith(p2.getHurtbox())) {
                    p2.takeHit(p1.hitbox);
                    p1.hitbox = null; 
                }
                if (p2.hitbox && p2.isHittable(p1) && p2.hitbox.collidesWith(p1.getHurtbox())) {
                    p1.takeHit(p2.hitbox);
                    p2.hitbox = null;
                }
            }

            async sendStateToFirestore(myPlayerData) {
                if (!myPlayerData) return;
                const updatePath = this.playerNumber === 1 ? "p1" : "p2";
                try {
                    await updateDoc(doc(db, "ultimate-brawl-games", this.currentGameId), {
                        [updatePath]: myPlayerData.getState()
                    });
                } catch(e) { console.error("Firestore update failed:", e); }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#8c8cde';
                this.platforms.forEach(p => this.ctx.fillRect(p.x, p.y, p.width, p.height));

                this.projectiles.forEach(p => p.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));

                if (this.players.p1) this.players.p1.draw(this.ctx);
                if (this.players.p2) this.players.p2.draw(this.ctx);
                
                this.updateHUD();
            }

            updateHUD() {
                if (this.players.p1) {
                    this.ui.p1Hud.damage.textContent = `${Math.floor(this.players.p1.damage)}%`;
                    this.ui.p1Hud.stocks.textContent = `P1 ${'‚ù§Ô∏è'.repeat(this.players.p1.stocks)}`;
                }
                if (this.players.p2) {
                    this.ui.p2Hud.damage.textContent = `${Math.floor(this.players.p2.damage)}%`;
                    this.ui.p2Hud.stocks.textContent = `${'‚ù§Ô∏è'.repeat(this.players.p2.stocks)} P2`;
                }
            }

            endGame(winnerUID) {
                if(this.state === 'GAMEOVER') return;
                this.setState('GAMEOVER');
                this.ui.result.textContent = winnerUID === this.currentUser.uid ? "VICTOIRE !" : "D√âFAITE...";
                this.cleanupGameLogic();
            }
            
            async rematch() {
                this.cleanup();
                this.setState('CHAR_SELECT');
            }

            setupKeyboardListeners() {
                this.keys = {};
                window.onkeydown = e => this.keys[e.code] = true;
                window.onkeyup = e => this.keys[e.code] = false;
            }

            cleanupGameLogic() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
                this.players = {};
                this.projectiles = [];
                this.particles = [];
                this.keys = {};
            }

            cleanup() {
                this.cleanupGameLogic();
                if (this.gameListener) this.gameListener();
                this.gameListener = null;
                this.currentGameId = null;
                this.playerNumber = null;
                this.state = 'IDLE';
            }
        }

        class Player {
            constructor(state, game) {
                this.game = game;
                this.char = CHARACTERS[state.charId];
                Object.assign(this, state);
            }

            getState() {
                return {
                    uid: this.uid, charId: this.charId, x: this.x, y: this.y,
                    vx: this.vx, vy: this.vy, damage: this.damage, stocks: this.stocks,
                    facing: this.facing, action: this.action, actionFrame: this.actionFrame,
                    jumpsLeft: this.jumpsLeft, isGrounded: this.isGrounded, invincibleUntil: this.invincibleUntil
                };
            }

            update() {
                if (Date.now() < this.invincibleUntil) {
                    this.action = 'invincible';
                } else if (this.action === 'hitstun' || this.action === 'invincible') {
                    this.action = 'idle';
                }

                // Appliquer la physique si pas en hitstun
                if (this.action !== 'hitstun') {
                    this.x += this.vx;
                    this.vx *= this.game.FRICTION;
                } else {
                     this.x += this.vx;
                     this.y += this.vy;
                }
                
                this.vy += this.game.GRAVITY;
                this.y += this.vy;

                // Collisions avec les plateformes
                this.isGrounded = false;
                this.game.platforms.forEach(p => {
                    if (this.y + this.char.size.h >= p.y && this.y + this.char.size.h <= p.y + p.height &&
                        this.x + this.char.size.w >= p.x && this.x <= p.x + p.width && this.vy > 0) {
                        this.vy = 0;
                        this.y = p.y - this.char.size.h;
                        this.isGrounded = true;
                        this.jumpsLeft = 2;
                    }
                });
                
                // Mettre √† jour l'action et la hitbox
                this.updateAction();

                // V√©rifier si le joueur est hors limites
                if (this.y > this.game.canvas.height + 100 || this.x < -100 || this.x > this.game.canvas.width + 100) {
                    this.loseStock();
                }
            }
            
            handleControls(keys) {
                if (this.action !== 'idle' && this.action !== 'run' && this.action !== 'jump') return;
                
                // Mouvement horizontal
                if (keys['ArrowLeft']) { this.vx = -this.game.PLAYER_SPEED; this.facing = -1; }
                if (keys['ArrowRight']) { this.vx = this.game.PLAYER_SPEED; this.facing = 1; }
                
                // Saut
                if (keys['ArrowUp'] && this.jumpsLeft > 0) {
                    this.vy = this.game.JUMP_FORCE;
                    this.jumpsLeft--;
                    keys['ArrowUp'] = false; // Consommer le saut
                }

                // Attaques
                if (keys['KeyJ']) this.performAttack('quick');
                if (keys['KeyK']) this.performAttack('strong');
            }
            
            updateAction() {
                if (this.action.includes('attack') || this.action === 'hitstun' || this.action === 'invincible') {
                    this.actionFrame--;
                    if (this.actionFrame <= 0) {
                        this.action = 'idle';
                        this.hitbox = null;
                    }
                }
            }

            performAttack(type) {
                const attack = this.char.attacks[type];
                if (this.action !== 'idle' && this.action !== 'run' && this.action !== 'jump') return;

                this.action = `${type}_attack`;
                this.actionFrame = attack.duration + (attack.startup || 0);
                
                setTimeout(() => {
                    if (this.action !== `${type}_attack`) return; // Action annul√©e
                    this.hitbox = new Hitbox(this, attack);
                }, (attack.startup || 0) * (1000/60)); // Convertir les frames en ms
            }

            takeHit(hitbox) {
                if (Date.now() < this.invincibleUntil) return;
                
                this.damage += hitbox.damage;
                const totalKnockback = hitbox.knockbackBase + (this.damage * hitbox.knockbackScale / this.char.weight);
                
                this.vx = totalKnockback * hitbox.owner.facing;
                this.vy = -totalKnockback * 0.7; // Angle d'√©jection vers le haut
                
                this.action = 'hitstun';
                this.actionFrame = totalKnockback * 2; // Le hitstun d√©pend de la puissance du coup
                this.isGrounded = false;
                
                // Particules d'impact
                for(let i = 0; i < 15; i++) {
                    this.game.particles.push(new Particle(this.x + this.char.size.w / 2, this.y + this.char.size.h / 2));
                }
            }

            loseStock() {
                if (Date.now() < this.invincibleUntil) return;
                this.stocks--;
                if(this.stocks <= 0) {
                    // Le jeu est termin√©, l'autre joueur gagne
                    // L'√©tat sera envoy√© √† Firestore, qui d√©clenchera la fin de partie
                } else {
                    this.respawn();
                }
            }

            respawn() {
                this.x = this.game.canvas.width / 2;
                this.y = 100;
                this.vx = 0;
                this.vy = 0;
                this.damage = 0;
                this.invincibleUntil = Date.now() + 2000; // 2 secondes d'invincibilit√©
            }

            getHurtbox() {
                return { x: this.x, y: this.y, w: this.char.size.w, h: this.char.size.h };
            }

            isHittable(otherPlayer) {
                return Date.now() > otherPlayer.invincibleUntil;
            }

            draw(ctx) {
                ctx.save();
                if (Date.now() < this.invincibleUntil && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Dessin simple bas√© sur l'emoji
                ctx.font = `${this.char.size.h}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(this.char.emoji, this.x + this.char.size.w / 2, this.y + this.char.size.h - 5);
                
                ctx.restore();

                // Debug Hitbox
                if (this.hitbox) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(this.hitbox.x, this.hitbox.y, this.hitbox.w, this.hitbox.h);
                }
            }
        }
        
        class Hitbox {
            constructor(owner, attack) {
                this.owner = owner;
                this.damage = attack.damage;
                this.knockbackBase = attack.knockbackBase;
                this.knockbackScale = attack.knockbackScale;

                const ownerBox = owner.getHurtbox();
                this.w = attack.hitbox.w;
                this.h = attack.hitbox.h;
                this.y = ownerBox.y + (ownerBox.h / 2) - (this.h / 2);

                if (owner.facing > 0) {
                    this.x = ownerBox.x + ownerBox.w;
                } else {
                    this.x = ownerBox.x - this.w;
                }
            }

            collidesWith(hurtbox) {
                return this.x < hurtbox.x + hurtbox.w &&
                       this.x + this.w > hurtbox.x &&
                       this.y < hurtbox.y + hurtbox.h &&
                       this.y + this.h > hurtbox.y;
            }
        }
        
        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30;
                this.size = Math.random() * 5 + 2;
                this.color = 'orange';
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life--;
                return this.life > 0;
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 30;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        window.game = new Game();

    </script>
</body>
</html>
