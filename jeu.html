<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frieren & JÃ¤germaister - Tank Brawl</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            background: #0a0a14;
            color: #fff;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .hidden { display: none !important; }

        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .screen h1 {
            font-size: 4em;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
            margin-bottom: 30px;
        }
        .screen button {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            padding: 15px 30px;
            border: 3px solid #f0f;
            background: transparent;
            color: #f0f;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px;
            box-shadow: inset 0 0 10px #f0f, 0 0 10px #f0f;
        }
        .screen button:hover { background: #f0f; color: #0a0a14; }

        #game-container {
            position: relative;
            border: 4px solid #f0f;
            box-shadow: 0 0 25px #f0f;
            cursor: crosshair;
        }
        
        canvas { display: block; background: #2c2c3e; }

        #score-hud {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 3em;
            text-shadow: 0 0 10px #fff;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading-screen" class="screen">
        <h1>Connexion...</h1>
    </div>

    <div id="login-screen" class="screen hidden">
        <h1>Tank Brawl</h1>
        <a href="index.html" style="text-decoration: none;"><button>Connexion requise</button></a>
    </div>
    
    <div id="matchmaking-screen" class="screen hidden">
        <h1>Recherche d'un adversaire...</h1>
        <button onclick="window.game.cancelMatchmaking()">Annuler</button>
    </div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas"></canvas>
        <div id="score-hud">0 - 0</div>
    </div>
    
    <div id="game-over-screen" class="screen hidden">
        <h1 id="game-result"></h1>
        <button onclick="window.game.returnToLobby()">Retourner au Lobby</button>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, onSnapshot, collection, query, where, limit, getDocs, updateDoc, deleteDoc, setDoc, serverTimestamp, addDoc, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyBhyxeEHBKrhuECJKt2d7NwSN7lcv39IX0",
            authDomain: "frieren-2-79e0c.firebaseapp.com",
            projectId: "frieren-2-79e0c",
            storageBucket: "frieren-2-79e0c.appspot.com",
            messagingSenderId: "861104473745",
            appId: "1:861104473745:web:377da7b0daaf5570572130"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 1200;
                this.canvas.height = 750;

                this.state = 'LOADING';
                this.currentUser = null;
                this.currentGameId = null;
                this.gameListener = null;
                this.lobbyListener = null;
                this.playerNumber = null;
                this.myLobbyId = null;

                this.tanks = {};
                this.bullets = {};
                this.walls = [];
                
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.animationFrameId = null;
                this.lastSentState = '';

                this.initUI();
                this.authCheck();
            }

            initUI() {
                this.ui = {
                    loading: document.getElementById('loading-screen'),
                    login: document.getElementById('login-screen'),
                    matchmaking: document.getElementById('matchmaking-screen'),
                    game: document.getElementById('game-container'),
                    gameOver: document.getElementById('game-over-screen'),
                    score: document.getElementById('score-hud'),
                    result: document.getElementById('game-result')
                };
            }
            
            setState(newState) {
                if (this.state === newState) return;
                this.state = newState;
                Object.values(this.ui).forEach(el => el.classList.add('hidden'));
                const screenKey = newState.toLowerCase().split('_')[0];
                if (this.ui[screenKey]) this.ui[screenKey].classList.remove('hidden');
            }

            authCheck() {
                onAuthStateChanged(auth, user => {
                    if (user) {
                        this.currentUser = user;
                        if (this.state === 'LOADING' || this.state === 'LOGIN') {
                            this.startMatchmaking();
                        }
                    } else {
                        this.currentUser = null;
                        this.cleanup();
                        this.setState('LOGIN');
                    }
                });
            }
            
            async startMatchmaking() {
                this.cleanup();
                this.setState('MATCHMAKING');

                // Add self to lobby
                const lobbyPlayer = {
                    uid: this.currentUser.uid,
                    username: this.currentUser.displayName || "Joueur",
                    timestamp: serverTimestamp()
                };
                const docRef = await addDoc(collection(db, "tank-lobby"), lobbyPlayer);
                this.myLobbyId = docRef.id;

                // Look for an opponent
                const q = query(collection(db, "tank-lobby"), where("uid", "!=", this.currentUser.uid), limit(1));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const opponentDoc = querySnapshot.docs[0];
                    // Found someone, create game as P1
                    const batch = writeBatch(db);
                    const newGameRef = doc(collection(db, "tank-games"));
                    this.currentGameId = newGameRef.id;
                    this.playerNumber = 1;

                    batch.set(newGameRef, this.getInitialGameState(opponentDoc.data()));
                    batch.delete(doc(db, "tank-lobby", this.myLobbyId));
                    batch.delete(doc(db, "tank-lobby", opponentDoc.id));
                    await batch.commit();
                    
                    this.listenToGame();
                } else {
                    // No one found, wait for someone to create a game with us
                    this.waitForOpponent();
                }
            }
            
            waitForOpponent() {
                this.lobbyListener = onSnapshot(query(collection(db, "tank-games"), where("p2.uid", "==", this.currentUser.uid), limit(1)), (snapshot) => {
                    if (!snapshot.empty) {
                        const gameDoc = snapshot.docs[0];
                        this.cleanupLobbyListener();
                        this.currentGameId = gameDoc.id;
                        this.playerNumber = 2;
                        this.listenToGame();
                    }
                });
            }

            async cancelMatchmaking() {
                if(this.myLobbyId) {
                    await deleteDoc(doc(db, "tank-lobby", this.myLobbyId));
                }
                this.cleanup();
                window.location.href = 'index.html'; // Redirect to main menu
            }

            getInitialGameState(opponent) {
                return {
                    status: "playing",
                    p1: { uid: this.currentUser.uid, username: this.currentUser.displayName, score: 0, ...this.createTankState(1) },
                    p2: { uid: opponent.uid, username: opponent.username, score: 0, ...this.createTankState(2) },
                    bullets: {},
                    mapSeed: Math.random()
                };
            }

            createTankState(playerNum) {
                return {
                    x: playerNum === 1 ? 100 : this.canvas.width - 100,
                    y: this.canvas.height / 2,
                    angle: 0,
                    turretAngle: playerNum === 1 ? 0 : Math.PI,
                    health: 100,
                    lastShot: 0
                };
            }

            listenToGame() {
                this.cleanupLobbyListener();
                if (this.gameListener) this.gameListener();
                this.gameListener = onSnapshot(doc(db, "tank-games", this.currentGameId), (docSnap) => {
                    if (!docSnap.exists()) {
                        this.returnToLobby();
                        return;
                    }
                    const gameState = docSnap.data();
                    if (this.state !== 'PLAYING') this.startGame(gameState);
                    
                    if (!this.tanks.p1) this.tanks.p1 = new Tank(gameState.p1, this); else this.tanks.p1.syncState(gameState.p1);
                    if (!this.tanks.p2) this.tanks.p2 = new Tank(gameState.p2, this); else this.tanks.p2.syncState(gameState.p2);
                    
                    this.bullets = gameState.bullets || {};
                    this.ui.score.textContent = `${gameState.p1.score} - ${gameState.p2.score}`;

                    if(this.mapSeed !== gameState.mapSeed) {
                        this.mapSeed = gameState.mapSeed;
                        this.generateMap(this.mapSeed);
                    }
                });
            }

            startGame(initialState) {
                this.setState('PLAYING');
                this.setupInputListeners();
                this.mapSeed = initialState.mapSeed;
                this.generateMap(this.mapSeed);
                if (!this.animationFrameId) this.gameLoop();
            }

            gameLoop() {
                this.update();
                this.draw();
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.state !== 'PLAYING' || !this.tanks.p1 || !this.tanks.p2) return;
                const myTank = this.playerNumber === 1 ? this.tanks.p1 : this.tanks.p2;
                
                myTank.handleControls(this.keys, this.mouse, this.walls);
                
                if (this.playerNumber === 1) {
                    this.updateBulletsAndCollisions();
                }
                
                this.sendStateToFirestore();
            }
            
            async updateBulletsAndCollisions() {
                const batch = writeBatch(db);
                const gameRef = doc(db, "tank-games", this.currentGameId);
                let changes = false;
                let newBullets = { ...this.bullets };

                for (const id in newBullets) {
                    let bullet = newBullets[id];
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    bullet.life--;

                    let hitWall = false;
                    for (const wall of this.walls) {
                        if (bullet.x < wall.x + wall.w && bullet.x + bullet.size > wall.x && bullet.y < wall.y + wall.h && bullet.y + bullet.size > wall.y) {
                            hitWall = true;
                            break;
                        }
                    }

                    const targetKey = bullet.owner === 'p1' ? 'p2' : 'p1';
                    const target = this.tanks[targetKey];
                    if (target && this.isColliding(bullet, target)) {
                        const newHealth = Math.max(0, target.health - 20);
                        batch.update(gameRef, { [`${targetKey}.health`]: newHealth });
                        delete newBullets[id];
                        changes = true;
                    } else if (bullet.life <= 0 || hitWall) {
                        delete newBullets[id];
                        changes = true;
                    } else {
                        newBullets[id] = bullet;
                    }
                }
                
                let playerDied = false;
                for (const key of ['p1', 'p2']) {
                    if(this.tanks[key] && this.tanks[key].health <= 0) {
                        this.handlePlayerDeath(key, batch);
                        playerDied = true;
                        break; 
                    }
                }

                if(changes && !playerDied) {
                    batch.update(gameRef, { bullets: newBullets });
                }
                await batch.commit().catch(e => {});
            }

            handlePlayerDeath(deadPlayerKey, batch) {
                const winnerKey = deadPlayerKey === 'p1' ? 'p2' : 'p1';
                const winner = this.tanks[winnerKey];
                const gameRef = doc(db, "tank-games", this.currentGameId);
                
                batch.update(gameRef, {
                    [`${winnerKey}.score`]: winner.score + 1,
                    mapSeed: Math.random(),
                    bullets: {},
                    p1: { ...this.tanks.p1.getState(), ...this.createTankState(1), health: 100, score: winnerKey === 'p2' ? this.tanks.p1.score : this.tanks.p1.score + 1 },
                    p2: { ...this.tanks.p2.getState(), ...this.createTankState(2), health: 100, score: winnerKey === 'p1' ? this.tanks.p2.score : this.tanks.p2.score + 1 }
                });
            }

            isColliding(rect1, rect2) {
                const size1 = rect1.size;
                const size2 = rect2.size;
                return rect1.x - size1/2 < rect2.x + size2 && rect1.x + size1/2 > rect2.x &&
                       rect1.y - size1/2 < rect2.y + size2 && rect1.y + size1/2 > rect2.y;
            }

            async sendStateToFirestore() {
                const myTank = this.playerNumber === 1 ? this.tanks.p1 : this.tanks.p2;
                const stateString = JSON.stringify(myTank.getState());

                if (stateString !== this.lastSentState) {
                    this.lastSentState = stateString;
                    const updatePath = this.playerNumber === 1 ? "p1" : "p2";
                    await updateDoc(doc(db, "tank-games", this.currentGameId), {
                        [updatePath]: myTank.getState()
                    }).catch(e => {});
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#555';
                this.walls.forEach(w => this.ctx.fillRect(w.x, w.y, w.w, w.h));
                
                Object.values(this.bullets).forEach(b => {
                    this.ctx.fillStyle = b.owner === 'p1' ? '#4ddbff' : '#ff9933';
                    this.ctx.beginPath();
                    this.ctx.arc(b.x, b.y, b.size / 2, 0, 2 * Math.PI);
                    this.ctx.fill();
                });

                if (this.tanks.p1) this.tanks.p1.draw(this.ctx);
                if (this.tanks.p2) this.tanks.p2.draw(this.ctx);
            }

            generateMap(seed) {
                this.walls = [];
                const rand = (s) => { s = Math.sin(s) * 10000; return s - Math.floor(s); };
                let randomSeed = seed * 1000;

                this.walls.push({ x: 0, y: 0, w: this.canvas.width, h: 20 });
                this.walls.push({ x: 0, y: this.canvas.height - 20, w: this.canvas.width, h: 20 });
                this.walls.push({ x: 0, y: 0, w: 20, h: this.canvas.height });
                this.walls.push({ x: this.canvas.width - 20, y: 0, w: 20, h: this.canvas.height });

                for(let i=0; i < 5; i++) {
                    randomSeed++; const x = rand(randomSeed) * (this.canvas.width - 300) + 150;
                    randomSeed++; const y = rand(randomSeed) * (this.canvas.height - 300) + 150;
                    randomSeed++; const w = rand(randomSeed) > 0.5 ? 250 : 40;
                    randomSeed++; const h = w === 250 ? 40 : 250;
                    this.walls.push({x, y, w, h});
                }
            }

            setupInputListeners() {
                this.keys = {}; this.mouse = { x: 0, y: 0, down: false };
                window.onkeydown = e => this.keys[e.code] = true;
                window.onkeyup = e => this.keys[e.code] = false;
                this.canvas.onmousemove = e => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left; this.mouse.y = e.clientY - rect.top;
                };
                this.canvas.onmousedown = () => this.mouse.down = true;
                this.canvas.onmouseup = () => this.mouse.down = false;
            }
            
            cleanupLobbyListener() {
                if(this.lobbyListener) this.lobbyListener();
                this.lobbyListener = null;
            }

            cleanup() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                if (this.gameListener) this.gameListener();
                this.cleanupLobbyListener();
                Object.assign(this, { animationFrameId: null, gameListener: null, currentGameId: null, playerNumber: null, myLobbyId: null, tanks: {}, keys: {}, mouse: {} });
            }

            returnToLobby() {
                this.cleanup();
                this.setState('MATCHMAKING');
                this.startMatchmaking();
            }
        }

        class Tank {
            constructor(state, game) { this.game = game; this.size = 40; this.turretLength = 35; this.speed = 3; this.syncState(state); }
            syncState(state) { Object.assign(this, state); }
            getState() { return { uid: this.uid, username: this.username, score: this.score, x: this.x, y: this.y, angle: this.angle, turretAngle: this.turretAngle, health: this.health, lastShot: this.lastShot }; }
            
            update(walls) { /* Server-driven state, local update is minimal */ }
            
            handleControls(keys, mouse, walls) {
                let dx = 0; let dy = 0;
                if (keys['KeyW'] || keys['KeyZ']) dy -= 1;
                if (keys['KeyS']) dy += 1;
                if (keys['KeyA'] || keys['KeyQ']) dx -= 1;
                if (keys['KeyD']) dx += 1;
                
                if (dx !== 0 || dy !== 0) {
                    const moveAngle = Math.atan2(dy, dx);
                    const newX = this.x + Math.cos(moveAngle) * this.speed;
                    const newY = this.y + Math.sin(moveAngle) * this.speed;
                    if (!this.checkWallCollision(newX, newY, walls)) {
                        this.x = newX;
                        this.y = newY;
                    }
                    this.angle = moveAngle;
                }
                
                this.turretAngle = Math.atan2(mouse.y - (this.y + this.size/2), mouse.x - (this.x + this.size/2));

                if (mouse.down && Date.now() - this.lastShot > 500) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
            }
            
            checkWallCollision(x, y, walls) {
                for (const wall of walls) {
                    if (x < wall.x + wall.w && x + this.size > wall.x && y < wall.y + wall.h && y + this.size > wall.y) {
                        return true;
                    }
                }
                return false;
            }

            async shoot() {
                const bulletId = doc(collection(db, "dummy")).id;
                const bullet = {
                    owner: this.game.playerNumber === 1 ? 'p1' : 'p2',
                    x: this.x + this.size / 2 + Math.cos(this.turretAngle) * this.turretLength,
                    y: this.y + this.size / 2 + Math.sin(this.turretAngle) * this.turretLength,
                    vx: Math.cos(this.turretAngle) * 15,
                    vy: Math.sin(this.turretAngle) * 15,
                    size: 10,
                    life: 100
                };
                await updateDoc(doc(db, "tank-games", this.game.currentGameId), {
                    [`bullets.${bulletId}`]: bullet
                });
            }

            draw(ctx) {
                // Body
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.uid === this.game.tanks.p1.uid ? '#4ddbff' : '#ff9933';
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.fillStyle = '#333';
                ctx.fillRect(-this.size/2, -this.size/2 + 5, this.size, 5);
                ctx.fillRect(-this.size/2, this.size/2 - 10, this.size, 5);
                ctx.restore();
                
                // Turret
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.turretAngle);
                ctx.fillStyle = '#999';
                ctx.fillRect(10, -5, this.turretLength, 10);
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                
                ctx.fillStyle = '#FFF'; ctx.font = '14px Orbitron'; ctx.textAlign = 'center';
                ctx.fillText(this.username, this.x + this.size/2, this.y - 20);

                ctx.fillStyle = '#222'; ctx.fillRect(this.x, this.y - 10, this.size, 5);
                ctx.fillStyle = this.health > 50 ? 'lime' : this.health > 20 ? 'orange' : 'red';
                ctx.fillRect(this.x, this.y - 10, this.size * (this.health/100), 5);
            }
        }
        
        window.game = new Game();
    </script>
</body>
</html>
