<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frieren & J√§germaister - Ultimate Brawl</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            background: #0a0a14;
            color: #fff;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .hidden { display: none !important; }

        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .screen h1 {
            font-size: 4em;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
            margin-bottom: 30px;
        }
        .screen h2 {
            font-size: 2.5em;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
        }
        .screen button {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            padding: 15px 30px;
            border: 3px solid #f0f;
            background: transparent;
            color: #f0f;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px;
            box-shadow: inset 0 0 10px #f0f, 0 0 10px #f0f;
        }
        .screen button:hover {
            background: #f0f;
            color: #0a0a14;
        }
        .screen button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            background: transparent;
            color: #f0f;
        }

        #character-select { display: flex; gap: 40px; }
        .char-card {
            border: 4px solid #0ff;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .char-card:hover, .char-card.selected {
            transform: scale(1.1);
            background: #0ff;
            color: #0a0a14;
            box-shadow: 0 0 25px #0ff;
        }
        .char-card h3 { font-size: 2em; margin-top: 0; }
        .char-card p { font-size: 4em; margin-bottom: 0; }

        #game-container {
            position: relative;
            border: 4px solid #f0f;
            box-shadow: 0 0 25px #f0f;
        }
        
        canvas {
            display: block;
            background: #1a1a2e;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
        }
        .player-hud {
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 15px;
        }
        .player-hud .stocks { font-size: 2em; }
        .player-hud .damage { font-size: 3em; font-weight: bold; min-width: 120px; text-align: center; }
        #player1-hud { color: #4ddbff; border: 2px solid #4ddbff; }
        #player2-hud { color: #ff9933; border: 2px solid #ff9933; }
    </style>
</head>
<body>

    <div id="loading-screen" class="screen">
        <h1>Connexion au serveur...</h1>
    </div>

    <div id="login-screen" class="screen hidden">
        <h1>Ultimate Brawl</h1>
        <p style="font-size: 1.2em;">Veuillez vous connecter via la page principale pour jouer.</p>
        <a href="index.html" style="text-decoration: none;"><button>Retour au Site</button></a>
    </div>

    <div id="char-select-screen" class="screen hidden">
        <h1>Choisissez votre combattant</h1>
        <div id="character-select">
            <div class="char-card" id="char-frieren" onclick="window.game.selectCharacter('frieren')">
                <p>üßô‚Äç‚ôÄÔ∏è</p>
                <h3>Frieren</h3>
            </div>
            <div class="char-card" id="char-jagermeister" onclick="window.game.selectCharacter('jagermeister')">
                <p>ü¶å</p>
                <h3>J√§germaister</h3>
            </div>
        </div>
        <p id="char-select-status" style="font-size: 1.5em; min-height: 2em;">En attente de votre choix...</p>
        <button id="confirm-char-btn" disabled onclick="window.game.confirmCharacterSelection()">Rechercher une partie</button>
    </div>

    <div id="matchmaking-screen" class="screen hidden">
        <h1>Recherche d'un adversaire...</h1>
        <button onclick="window.game.cancelMatchmaking()">Annuler</button>
    </div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="player1-hud" class="player-hud">
                <div class="stocks">P1 ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                <div class="damage">0%</div>
            </div>
            <div id="player2-hud" class="player-hud">
                <div class="damage">0%</div>
                <div class="stocks">P2 ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
        </div>
    </div>
    
    <div id="game-over-screen" class="screen hidden">
        <h1 id="game-result"></h1>
        <button onclick="window.game.rematch()">Rejouer</button>
        <a href="index.html" style="text-decoration: none;"><button>Menu Principal</button></a>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, onSnapshot, collection, query, where, limit, getDocs, updateDoc, deleteDoc, setDoc, serverTimestamp, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        const firebaseConfig = {
          apiKey: "AIzaSyBhyxeEHBKrhuECJKt2d7NwSN7lcv39IX0",
          authDomain: "frieren-2-79e0c.firebaseapp.com",
          projectId: "frieren-2-79e0c",
          storageBucket: "frieren-2-79e0c.appspot.com",
          messagingSenderId: "861104473745",
          appId: "1:861104473745:web:377da7b0daaf5570572130"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const CHARACTERS = {
            frieren: {
                name: 'Frieren', color: '#4ddbff', emoji: 'üßô‚Äç‚ôÄÔ∏è', size: { w: 40, h: 55 }, weight: 0.9,
                attacks: {
                    quick: { type: 'projectile', hitbox: { w: 20, h: 20 }, damage: 3, knockbackBase: 3, knockbackScale: 0.1, speed: 12, duration: 30, cooldown: 25 },
                    strong: { type: 'beam', hitbox: { w: 150, h: 30 }, damage: 10, knockbackBase: 6, knockbackScale: 0.5, duration: 25, cooldown: 80, startup: 15 }
                }
            },
            jagermeister: {
                name: 'J√§germaister', color: '#ff9933', emoji: 'ü¶å', size: { w: 50, h: 50 }, weight: 1.1,
                attacks: {
                    quick: { type: 'punch', hitbox: { w: 50, h: 30 }, damage: 6, knockbackBase: 5, knockbackScale: 0.4, duration: 10, cooldown: 30, startup: 5 },
                    strong: { type: 'stomp', hitbox: { w: 100, h: 25 }, damage: 14, knockbackBase: 8, knockbackScale: 0.8, duration: 20, cooldown: 100, startup: 20 }
                }
            }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 1200;
                this.canvas.height = 700;
                
                this.GRAVITY = 0.6;
                this.JUMP_FORCE = -15;
                this.PLAYER_SPEED = 6;
                this.FRICTION = 0.85;

                this.state = 'LOADING';
                this.currentUser = null;
                this.currentGameId = null;
                this.gameListener = null;
                this.playerNumber = null;
                this.myCharId = null;
                
                this.players = {};
                this.platforms = [
                    { x: 200, y: 550, width: 800, height: 30 },
                    { x: 300, y: 400, width: 200, height: 20 },
                    { x: 700, y: 400, width: 200, height: 20 }
                ];
                this.projectiles = [];
                this.particles = [];
                this.keys = {};
                this.animationFrameId = null;

                this.initUI();
                this.authCheck();
            }

            initUI() {
                this.ui = {
                    loading: document.getElementById('loading-screen'),
                    login: document.getElementById('login-screen'),
                    charSelect: document.getElementById('char-select-screen'),
                    charSelectStatus: document.getElementById('char-select-status'),
                    confirmCharBtn: document.getElementById('confirm-char-btn'),
                    matchmaking: document.getElementById('matchmaking-screen'),
                    game: document.getElementById('game-container'),
                    gameOver: document.getElementById('game-over-screen'),
                    p1Hud: { damage: document.querySelector('#player1-hud .damage'), stocks: document.querySelector('#player1-hud .stocks') },
                    p2Hud: { damage: document.querySelector('#player2-hud .damage'), stocks: document.querySelector('#player2-hud .stocks') },
                    result: document.getElementById('game-result')
                };
            }
            
            setState(newState) {
                this.state = newState;
                for (const key in this.ui) {
                    if (this.ui[key].classList && !this.ui[key].id.includes('hud')) {
                        this.ui[key].classList.add('hidden');
                    }
                }
                const screenKey = newState.toLowerCase().split('_')[0];
                if(this.ui[screenKey]) this.ui[screenKey].classList.remove('hidden');
            }

            authCheck() {
                onAuthStateChanged(auth, user => {
                    if (user) {
                        this.currentUser = user;
                        if(this.state === 'LOADING' || this.state === 'LOGIN') {
                            this.setState('CHAR_SELECT');
                        }
                    } else {
                        this.currentUser = null;
                        this.setState('LOGIN');
                        this.cleanup();
                    }
                });
            }

            selectCharacter(charId) {
                if (this.state !== 'CHAR_SELECT') return;
                this.myCharId = charId;
                document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                document.getElementById(`char-${charId}`).classList.add('selected');
                this.ui.confirmCharBtn.disabled = false;
            }
            
            confirmCharacterSelection() {
                if (!this.myCharId) return;
                this.ui.confirmCharBtn.disabled = true;
                this.startMatchmaking();
            }

            async startMatchmaking() {
                this.setState('MATCHMAKING');

                const q = query(collection(db, "ultimate-brawl-games"), where("status", "==", "waiting"), limit(1));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const gameDoc = querySnapshot.docs[0];
                    if (gameDoc.data().p1.uid !== this.currentUser.uid) {
                        this.currentGameId = gameDoc.id;
                        this.playerNumber = 2;
                        await updateDoc(doc(db, "ultimate-brawl-games", this.currentGameId), {
                            "p2.uid": this.currentUser.uid,
                            "p2.username": this.currentUser.displayName || "Joueur 2",
                            "p2.charId": this.myCharId,
                            status: "playing",
                            lastUpdate: serverTimestamp()
                        });
                        this.listenToGame();
                    } else {
                        this.currentGameId = gameDoc.id;
                        this.playerNumber = 1;
                        this.listenToGame();
                    }
                } else {
                    const newGameRef = doc(collection(db, "ultimate-brawl-games"));
                    this.currentGameId = newGameRef.id;
                    this.playerNumber = 1;
                    await setDoc(newGameRef, this.getInitialGameState());
                    this.listenToGame();
                }
            }
            
            async cancelMatchmaking() {
                if (this.gameListener) this.gameListener();
                if (this.currentGameId && this.playerNumber === 1) {
                    await deleteDoc(doc(db, "ultimate-brawl-games", this.currentGameId));
                }
                this.cleanup();
                this.setState('CHAR_SELECT');
                this.resetCharSelectUI();
            }
            
            resetCharSelectUI() {
                this.ui.charSelectStatus.textContent = 'En attente de votre choix...';
                this.ui.confirmCharBtn.disabled = true;
                this.myCharId = null;
                document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
            }

            getInitialGameState() {
                return {
                    status: "waiting",
                    p1: this.createPlayerState(1, this.currentUser.uid, this.myCharId),
                    p2: this.createPlayerState(2, null, null),
                    lastUpdate: serverTimestamp(),
                    winner: null
                };
            }

            createPlayerState(playerNum, uid, charId) {
                const spawnX = playerNum === 1 ? this.canvas.width / 4 : (this.canvas.width / 4) * 3;
                return {
                    uid: uid,
                    username: playerNum === 1 ? (this.currentUser.displayName || "Joueur 1") : null,
                    charId: charId,
                    x: spawnX, y: 100, vx: 0, vy: 0,
                    damage: 0, stocks: 3, facing: playerNum === 1 ? 1 : -1,
                    action: 'idle', actionFrame: 0,
                    jumpsLeft: 2, isGrounded: false, invincibleUntil: 0
                };
            }

            listenToGame() {
                if (this.gameListener) this.gameListener();
                this.gameListener = onSnapshot(doc(db, "ultimate-brawl-games", this.currentGameId), (doc) => {
                    if (!doc.exists()) {
                        if(this.state === 'PLAYING') alert("L'adversaire a quitt√© la partie.");
                        this.cancelMatchmaking();
                        return;
                    }
                    
                    const gameState = doc.data();
                    if (gameState.status === 'playing') {
                        if (this.state !== 'PLAYING') this.startGame(gameState);
                        
                        if(!this.players.p1) this.players.p1 = new Player(gameState.p1, this);
                        else this.players.p1.syncState(gameState.p1);
                        
                        if(!this.players.p2) this.players.p2 = new Player(gameState.p2, this);
                        else this.players.p2.syncState(gameState.p2);
                        
                    }
                    if (gameState.status === 'finished') {
                        this.endGame(gameState.winner);
                    }
                });
            }

            startGame(initialState) {
                this.setState('PLAYING');
                this.players = { p1: new Player(initialState.p1, this), p2: new Player(initialState.p2, this) };
                this.setupKeyboardListeners();
                if(!this.animationFrameId) this.gameLoop();
            }

            gameLoop() {
                this.update();
                this.draw();
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.state !== 'PLAYING' || !this.players.p1 || !this.players.p2 || !this.playerNumber) return;
                
                const myPlayer = this.playerNumber === 1 ? this.players.p1 : this.players.p2;
                
                if (myPlayer.uid === this.currentUser.uid) {
                    myPlayer.handleControls(this.keys);
                }
                
                Object.values(this.players).forEach(p => p.update());
                
                this.checkHitCollisions();
                
                this.projectiles = this.projectiles.filter(p => p.update());
                this.particles = this.particles.filter(p => p.life > 0);
                
                if (this.currentUser && myPlayer.uid === this.currentUser.uid) {
                   this.sendStateToFirestore(myPlayer);
                }
            }

            checkHitCollisions() {
                const p1 = this.players.p1;
                const p2 = this.players.p2;
                if(!p1 || !p2 || !p1.char || !p2.char) return;

                const check = (attacker, defender) => {
                    if (attacker.hitbox && attacker.isHittable(defender) && attacker.hitbox.collidesWith(defender.getHurtbox())) {
                        defender.takeHit(attacker.hitbox);
                        attacker.hitbox = null; 
                    }
                };
                check(p1, p2);
                check(p2, p1);

                this.projectiles.forEach(proj => {
                    const target = proj.owner === p1 ? p2 : p1;
                    if (target && proj.active && proj.collidesWith(target.getHurtbox())) {
                        target.takeHit(proj);
                        proj.active = false;
                    }
                });
            }

            async sendStateToFirestore(myPlayerData) {
                if (!myPlayerData || !this.currentGameId || this.state !== 'PLAYING') return;
                const updatePath = this.playerNumber === 1 ? "p1" : "p2";
                try {
                    const currentState = myPlayerData.getState();
                    if(currentState.stocks <= 0) {
                        await updateDoc(doc(db, "ultimate-brawl-games", this.currentGameId), {
                            status: 'finished',
                            winner: this.playerNumber === 1 ? this.players.p2.uid : this.players.p1.uid
                        });
                    } else {
                        await updateDoc(doc(db, "ultimate-brawl-games", this.currentGameId), {
                            [updatePath]: currentState
                        });
                    }
                } catch(e) { /* Error handling */ }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.fillStyle = '#8c8cde';
                this.platforms.forEach(p => this.ctx.fillRect(p.x, p.y, p.width, p.height));

                this.projectiles.forEach(p => p.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));

                if (this.players.p1) this.players.p1.draw(this.ctx);
                if (this.players.p2) this.players.p2.draw(this.ctx);
                
                this.updateHUD();
            }

            updateHUD() {
                if (this.players.p1 && this.players.p1.char) {
                    this.ui.p1Hud.damage.textContent = `${Math.floor(this.players.p1.damage)}%`;
                    this.ui.p1Hud.stocks.textContent = `P1 ${'‚ù§Ô∏è'.repeat(this.players.p1.stocks)}`;
                }
                if (this.players.p2 && this.players.p2.char) {
                    this.ui.p2Hud.damage.textContent = `${Math.floor(this.players.p2.damage)}%`;
                    this.ui.p2Hud.stocks.textContent = `${'‚ù§Ô∏è'.repeat(this.players.p2.stocks)} P2`;
                }
            }

            endGame(winnerUID) {
                if(this.state === 'GAMEOVER') return;
                this.setState('GAMEOVER');
                this.ui.result.textContent = winnerUID === this.currentUser.uid ? "VICTOIRE !" : "D√âFAITE...";
                this.cleanupGameLogic();
            }
            
            rematch() {
                this.cleanup();
                this.setState('CHAR_SELECT');
                this.resetCharSelectUI();
            }

            setupKeyboardListeners() {
                this.keys = {};
                window.onkeydown = e => this.keys[e.code] = true;
                window.onkeyup = e => {
                    this.keys[e.code] = false;
                    const myPlayer = this.playerNumber === 1 ? this.players.p1 : this.players.p2;
                    if(myPlayer) myPlayer.canDoubleJump = true;
                };
            }

            cleanupGameLogic() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
                this.players = {};
                this.projectiles = [];
                this.particles = [];
                this.keys = {};
            }

            cleanup() {
                this.cleanupGameLogic();
                if (this.gameListener) this.gameListener();
                this.gameListener = null;
                this.currentGameId = null;
                this.playerNumber = null;
                this.state = 'IDLE';
            }
        }

        class Player {
            constructor(state, game) {
                this.game = game;
                this.syncState(state);
                this.canDoubleJump = true;
            }

            syncState(state) {
                if(!state.charId && this.charId) return;
                this.charId = state.charId;
                if(this.charId) this.char = CHARACTERS[state.charId];
                Object.assign(this, state);
            }

            getState() {
                return {
                    uid: this.uid, username: this.username, charId: this.charId, x: this.x, y: this.y,
                    vx: this.vx, vy: this.vy, damage: this.damage, stocks: this.stocks,
                    facing: this.facing, action: this.action, actionFrame: this.actionFrame,
                    jumpsLeft: this.jumpsLeft, isGrounded: this.isGrounded, invincibleUntil: this.invincibleUntil
                };
            }

            update() {
                if(!this.char) return;
                
                if (Date.now() < this.invincibleUntil) this.action = 'invincible';
                else if (this.action === 'hitstun' || this.action === 'invincible') this.action = 'idle';

                if (this.action === 'hitstun') {
                    this.x += this.vx; this.y += this.vy;
                    this.vy += this.game.GRAVITY;
                    this.vx *= 0.98; this.vy *= 0.99;
                } else {
                    this.x += this.vx; this.vx *= this.game.FRICTION;
                    this.y += this.vy; this.vy += this.game.GRAVITY;
                }

                this.isGrounded = false;
                this.game.platforms.forEach(p => {
                    if (this.y + this.char.size.h >= p.y && this.y + this.char.size.h <= p.y + p.height &&
                        this.x + this.char.size.w > p.x && this.x < p.x + p.width && this.vy > 0) {
                        this.vy = 0;
                        this.y = p.y - this.char.size.h;
                        this.isGrounded = true;
                        if(this.action !== 'hitstun') this.jumpsLeft = 2;
                    }
                });
                
                this.updateAction();

                if (this.uid === this.game.currentUser.uid && (this.y > this.game.canvas.height + 150 || this.x < -150 || this.x > this.game.canvas.width + 150)) {
                    this.loseStock();
                }
            }
            
            handleControls(keys) {
                if (this.action.includes('attack') || this.action === 'hitstun') return;
                
                if (keys['ArrowLeft']) { this.vx = -this.game.PLAYER_SPEED; this.facing = -1; }
                if (keys['ArrowRight']) { this.vx = this.game.PLAYER_SPEED; this.facing = 1; }
                
                if (keys['ArrowUp']) {
                    if (this.jumpsLeft > 0 && this.canDoubleJump) {
                        this.vy = this.game.JUMP_FORCE;
                        this.jumpsLeft--;
                        this.isGrounded = false;
                        this.canDoubleJump = false;
                    }
                }

                if (keys['KeyJ']) this.performAttack('quick');
                if (keys['KeyK']) this.performAttack('strong');
            }
            
            updateAction() {
                if (this.action.includes('attack') || this.action === 'hitstun' || this.action === 'invincible') {
                    this.actionFrame--;
                    if (this.actionFrame <= 0) {
                        this.action = 'idle';
                        this.hitbox = null;
                    }
                }
            }

            performAttack(type) {
                const attack = this.char.attacks[type];
                if (this.action.includes('attack')) return;

                this.action = `${type}_attack`;
                this.actionFrame = attack.duration + (attack.startup || 0);
                
                setTimeout(() => {
                    if (this.action !== `${type}_attack`) return;
                    this.hitbox = new Hitbox(this, attack);
                }, (attack.startup || 0) * (1000/60));
            }

            takeHit(hitbox) {
                if (Date.now() < this.invincibleUntil) return;
                
                this.damage += hitbox.damage;
                const totalKnockback = hitbox.knockbackBase + (this.damage * hitbox.knockbackScale * 0.01 / this.char.weight);
                
                this.vx = totalKnockback * hitbox.owner.facing;
                this.vy = -totalKnockback * 0.7;
                
                this.action = 'hitstun';
                this.actionFrame = totalKnockback > 5 ? totalKnockback * 2.5 : 15;
                this.isGrounded = false;
                
                for(let i = 0; i < 15; i++) {
                    this.game.particles.push(new Particle(this.x + this.char.size.w / 2, this.y + this.char.size.h / 2));
                }
            }

            loseStock() {
                if (this.stocks > 0 && this.uid === this.game.currentUser.uid) {
                    this.stocks--;
                    this.respawn();
                }
            }

            respawn() {
                this.x = this.game.canvas.width / 2;
                this.y = 100;
                this.vx = 0; this.vy = 0; this.damage = 0;
                this.invincibleUntil = Date.now() + 2000;
            }

            getHurtbox() {
                return { x: this.x, y: this.y, w: this.char.size.w, h: this.char.size.h };
            }

            isHittable(otherPlayer) {
                return Date.now() > otherPlayer.invincibleUntil;
            }

            draw(ctx) {
                if(!this.char) return;
                ctx.save();
                if (Date.now() < this.invincibleUntil && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Dessin du personnage
                ctx.fillStyle = this.char.color;
                ctx.fillRect(this.x, this.y, this.char.size.w, this.char.size.h);
                
                // Dessin du pseudo
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '16px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(this.username || '', this.x + this.char.size.w / 2, this.y - 10);
                
                ctx.restore();

                // Affichage de la hitbox (uniquement pour le joueur local pour le debug)
                if (this.hitbox && this.uid === this.game.currentUser.uid) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(this.hitbox.x, this.hitbox.y, this.hitbox.w, this.hitbox.h);
                }
            }
        }
        
        class Hitbox {
            constructor(owner, attack) {
                this.owner = owner;
                Object.assign(this, attack);
                
                const ownerBox = owner.getHurtbox();
                this.w = attack.hitbox.w;
                this.h = attack.hitbox.h;
                this.y = ownerBox.y + (ownerBox.h / 2) - (this.h / 2);
                this.x = owner.facing > 0 ? ownerBox.x + ownerBox.w : ownerBox.x - this.w;
            }
            collidesWith(hurtbox) {
                return this.x < hurtbox.x + hurtbox.w && this.x + this.w > hurtbox.x &&
                       this.y < hurtbox.y + hurtbox.h && this.y + this.h > hurtbox.y;
            }
        }
        
        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 10; this.vy = (Math.random() - 0.5) * 10;
                this.life = 30;
                this.size = Math.random() * 5 + 2;
                this.color = `hsl(${Math.random() * 50 + 10}, 100%, 50%)`;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 30;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        class Projectile {
            // (La logique des projectiles peut √™tre ajout√©e ici si n√©cessaire pour Frieren)
        }

        window.game = new Game();

    </script>
</body>
</html>
