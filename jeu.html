<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frieren & JÃ¤germaister - Tank Brawl</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        
        body {
            font-family: 'Orbitron', sans-serif;
            background: #0a0a14;
            color: #fff;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .hidden { display: none !important; }

        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .screen h1 {
            font-size: 4em;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 30px #f0f;
            margin-bottom: 30px;
        }
        .screen button {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            padding: 15px 30px;
            border: 3px solid #f0f;
            background: transparent;
            color: #f0f;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px;
            box-shadow: inset 0 0 10px #f0f, 0 0 10px #f0f;
        }
        .screen button:hover { background: #f0f; color: #0a0a14; }

        #game-container {
            position: relative;
            border: 4px solid #f0f;
            box-shadow: 0 0 25px #f0f;
            cursor: crosshair;
        }
        
        canvas { display: block; background: #1a1a2e; }

        #score-hud {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 3em;
            text-shadow: 0 0 10px #fff;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading-screen" class="screen">
        <h1>Connexion...</h1>
    </div>

    <div id="login-screen" class="screen hidden">
        <h1>Tank Brawl</h1>
        <a href="index.html" style="text-decoration: none;"><button>Connexion requise</button></a>
    </div>
    
    <div id="lobby-screen" class="screen hidden">
        <h1>Lobby</h1>
        <button id="ready-btn" onclick="window.game.setReady()">Rechercher une partie</button>
    </div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas"></canvas>
        <div id="score-hud">0 - 0</div>
    </div>
    
    <div id="game-over-screen" class="screen hidden">
        <h1 id="game-result"></h1>
        <button onclick="window.game.returnToLobby()">Retour au Lobby</button>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, onSnapshot, collection, query, where, limit, getDocs, updateDoc, deleteDoc, setDoc, serverTimestamp, addDoc, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        
        const firebaseConfig = {
          apiKey: "AIzaSyBhyxeEHBKrhuECJKt2d7NwSN7lcv39IX0",
          authDomain: "frieren-2-79e0c.firebaseapp.com",
          projectId: "frieren-2-79e0c",
          storageBucket: "frieren-2-79e0c.appspot.com",
          messagingSenderId: "861104473745",
          appId: "1:8611044737445:web:377da7b0daaf5570572130"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 1200;
                this.canvas.height = 750;

                this.state = 'LOADING';
                this.currentUser = null;
                this.currentGameId = null;
                this.gameListener = null;
                this.playerNumber = null;
                this.myReadyId = null;

                this.tanks = {};
                this.bullets = [];
                this.walls = [];
                
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.animationFrameId = null;

                this.initUI();
                this.authCheck();
            }

            initUI() {
                this.ui = {
                    loading: document.getElementById('loading-screen'),
                    login: document.getElementById('login-screen'),
                    lobby: document.getElementById('lobby-screen'),
                    game: document.getElementById('game-container'),
                    gameOver: document.getElementById('game-over-screen'),
                    score: document.getElementById('score-hud'),
                    result: document.getElementById('game-result')
                };
            }
            
            setState(newState) {
                if (this.state === newState) return;
                this.state = newState;
                Object.values(this.ui).forEach(el => el.classList.add('hidden'));
                const screenKey = newState.toLowerCase().split('_')[0];
                if (this.ui[screenKey]) this.ui[screenKey].classList.remove('hidden');
            }

            authCheck() {
                onAuthStateChanged(auth, user => {
                    if (user) {
                        this.currentUser = user;
                        if (this.state === 'LOADING' || this.state === 'LOGIN') this.setState('LOBBY');
                    } else {
                        this.currentUser = null;
                        this.cleanup();
                        this.setState('LOGIN');
                    }
                });
            }

            async setReady() {
                this.ui.lobby.querySelector('button').disabled = true;
                
                const readyPlayer = {
                    uid: this.currentUser.uid,
                    username: this.currentUser.displayName || "Joueur",
                    timestamp: serverTimestamp()
                };
                
                const docRef = await addDoc(collection(db, "tank-lobby"), readyPlayer);
                this.myReadyId = docRef.id;
                this.startMatchmaking();
            }

            async startMatchmaking() {
                const q = query(collection(db, "tank-lobby"), where("uid", "!=", this.currentUser.uid), limit(1));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const opponentDoc = querySnapshot.docs[0];
                    
                    const batch = writeBatch(db);
                    const newGameRef = doc(collection(db, "tank-games"));
                    this.currentGameId = newGameRef.id;
                    this.playerNumber = 1;

                    batch.set(newGameRef, this.getInitialGameState(opponentDoc.data()));
                    batch.delete(doc(db, "tank-lobby", this.myReadyId));
                    batch.delete(doc(db, "tank-lobby", opponentDoc.id));
                    await batch.commit();
                    
                    this.listenToGame();
                } else {
                    this.waitForOpponent();
                }
            }
            
            waitForOpponent() {
                this.gameListener = onSnapshot(query(collection(db, "tank-games"), where("p2.uid", "==", this.currentUser.uid), where("status", "==", "playing"), limit(1)), (snapshot) => {
                    if (!snapshot.empty) {
                        const gameDoc = snapshot.docs[0];
                        this.currentGameId = gameDoc.id;
                        this.playerNumber = 2;
                        if (this.gameListener) this.gameListener(); // Stop this listener
                        this.listenToGame();
                    }
                });
            }

            getInitialGameState(opponent) {
                return {
                    status: "playing",
                    p1: { uid: this.currentUser.uid, username: this.currentUser.displayName, score: 0, ...this.createTankState(1) },
                    p2: { uid: opponent.uid, username: opponent.username, score: 0, ...this.createTankState(2) },
                    bullets: {},
                    mapSeed: Math.random()
                };
            }

            createTankState(playerNum) {
                return {
                    x: playerNum === 1 ? 100 : this.canvas.width - 100,
                    y: this.canvas.height / 2,
                    angle: 0,
                    turretAngle: 0,
                    health: 100,
                    lastShot: 0
                };
            }

            listenToGame() {
                if (this.gameListener) this.gameListener();
                this.gameListener = onSnapshot(doc(db, "tank-games", this.currentGameId), (docSnap) => {
                    if (!docSnap.exists()) {
                        this.returnToLobby();
                        return;
                    }
                    const gameState = docSnap.data();
                    if (this.state !== 'PLAYING') this.startGame(gameState);
                    
                    if (!this.tanks.p1) this.tanks.p1 = new Tank(gameState.p1, this); else this.tanks.p1.syncState(gameState.p1);
                    if (!this.tanks.p2) this.tanks.p2 = new Tank(gameState.p2, this); else this.tanks.p2.syncState(gameState.p2);
                    
                    this.bullets = Object.values(gameState.bullets || {});
                    this.ui.score.textContent = `${gameState.p1.score} - ${gameState.p2.score}`;

                    if(this.mapSeed !== gameState.mapSeed) {
                        this.mapSeed = gameState.mapSeed;
                        this.generateMap(this.mapSeed);
                    }
                });
            }

            startGame(initialState) {
                this.setState('PLAYING');
                this.setupInputListeners();
                this.mapSeed = initialState.mapSeed;
                this.generateMap(this.mapSeed);
                if (!this.animationFrameId) this.gameLoop();
            }

            gameLoop() {
                this.update();
                this.draw();
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.state !== 'PLAYING' || !this.tanks.p1 || !this.tanks.p2) return;
                const myTank = this.playerNumber === 1 ? this.tanks.p1 : this.tanks.p2;
                myTank.handleControls(this.keys, this.mouse);
                
                Object.values(this.tanks).forEach(t => t.update());
                
                this.checkCollisions();
                this.sendStateToFirestore();
            }

            checkCollisions() {
                const myTankKey = this.playerNumber === 1 ? 'p1' : 'p2';
                // Bullet collisions are only checked by P1 to avoid duplicate events
                if (this.playerNumber !== 1) return;

                const batch = writeBatch(db);
                let changes = false;

                Object.entries(this.bullets).forEach(([id, bullet]) => {
                    if(!bullet) return;
                    const targetKey = bullet.owner === 'p1' ? 'p2' : 'p1';
                    const target = this.tanks[targetKey];
                    
                    if (target && this.isColliding(bullet, target)) {
                        batch.update(doc(db, "tank-games", this.currentGameId), {
                            [`bullets.${id}`]: null,
                            [`${targetKey}.health`]: Math.max(0, target.health - 10)
                        });
                        changes = true;
                    }
                });

                if (changes) batch.commit();
            }
            
            isColliding(rect1, rect2) {
                return rect1.x < rect2.x + rect2.size &&
                       rect1.x + rect1.size > rect2.x &&
                       rect1.y < rect2.y + rect2.size &&
                       rect1.y + rect1.size > rect2.y;
            }

            async sendStateToFirestore() {
                const myTank = this.playerNumber === 1 ? this.tanks.p1 : this.tanks.p2;
                const updates = { [`p${this.playerNumber}`]: myTank.getState() };
                await updateDoc(doc(db, "tank-games", this.currentGameId), updates);
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#555';
                this.walls.forEach(w => this.ctx.fillRect(w.x, w.y, w.w, w.h));
                
                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.owner === 'p1' ? '#4ddbff' : '#ff9933';
                    this.ctx.fillRect(b.x, b.y, b.size, b.size);
                });

                if (this.tanks.p1) this.tanks.p1.draw(this.ctx);
                if (this.tanks.p2) this.tanks.p2.draw(this.ctx);
            }

            generateMap(seed) {
                this.walls = [];
                const rand = (s) => { s = Math.sin(s) * 10000; return s - Math.floor(s); };
                let randomSeed = seed * 1000;

                this.walls.push({ x: 0, y: 0, w: this.canvas.width, h: 20 });
                this.walls.push({ x: 0, y: this.canvas.height - 20, w: this.canvas.width, h: 20 });
                this.walls.push({ x: 0, y: 0, w: 20, h: this.canvas.height });
                this.walls.push({ x: this.canvas.width - 20, y: 0, w: 20, h: this.canvas.height });

                for(let i=0; i < 5; i++) {
                    randomSeed++;
                    const x = rand(randomSeed) * (this.canvas.width - 200) + 100;
                    randomSeed++;
                    const y = rand(randomSeed) * (this.canvas.height - 200) + 100;
                    randomSeed++;
                    const w = rand(randomSeed) > 0.5 ? 200 : 30;
                    randomSeed++;
                    const h = w === 200 ? 30 : 200;
                    this.walls.push({x, y, w, h});
                }
            }
            
            async handlePlayerDeath(deadPlayerKey) {
                if (this.playerNumber !== 1) return; // Only P1 handles scoring
                
                const winnerKey = deadPlayerKey === 'p1' ? 'p2' : 'p1';
                const winner = this.tanks[winnerKey];
                
                const batch = writeBatch(db);
                const gameRef = doc(db, "tank-games", this.currentGameId);
                
                batch.update(gameRef, {
                    [`${winnerKey}.score`]: winner.score + 1,
                    mapSeed: Math.random(),
                    p1: { ...this.tanks.p1.getState(), ...this.createTankState(1), health: 100, score: winnerKey === 'p2' ? this.tanks.p1.score : this.tanks.p1.score + 1 },
                    p2: { ...this.tanks.p2.getState(), ...this.createTankState(2), health: 100, score: winnerKey === 'p1' ? this.tanks.p2.score : this.tanks.p2.score + 1 }
                });
                
                await batch.commit();
            }

            setupInputListeners() {
                this.keys = {}; this.mouse = { x: 0, y: 0, down: false };
                window.onkeydown = e => this.keys[e.code] = true;
                window.onkeyup = e => this.keys[e.code] = false;
                this.canvas.onmousemove = e => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                };
                this.canvas.onmousedown = () => this.mouse.down = true;
                this.canvas.onmouseup = () => this.mouse.down = false;
            }

            cleanup() {
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                if (this.gameListener) this.gameListener();
                Object.assign(this, { animationFrameId: null, gameListener: null, currentGameId: null, playerNumber: null, myReadyId: null, tanks: {}, keys: {}, mouse: {} });
            }

            returnToLobby() {
                this.cleanup();
                this.setState('LOBBY');
                this.ui.lobby.querySelector('button').disabled = false;
            }
        }

        class Tank {
            constructor(state, game) { this.game = game; this.size = 40; this.turretLength = 40; this.syncState(state); }
            syncState(state) { Object.assign(this, state); }
            getState() { return { uid: this.uid, username: this.username, score: this.score, x: this.x, y: this.y, angle: this.angle, turretAngle: this.turretAngle, health: this.health, lastShot: this.lastShot }; }
            
            update() {
                if (this.health <= 0) {
                    this.game.handlePlayerDeath(this.uid === this.game.tanks.p1.uid ? 'p1' : 'p2');
                }
            }
            
            handleControls(keys, mouse) {
                let dx = 0; let dy = 0;
                if (keys['KeyW'] || keys['KeyZ']) dy -= 1;
                if (keys['KeyS']) dy += 1;
                if (keys['KeyA'] || keys['KeyQ']) dx -= 1;
                if (keys['KeyD']) dx += 1;
                
                if (dx !== 0 || dy !== 0) {
                    const moveAngle = Math.atan2(dy, dx);
                    this.x += Math.cos(moveAngle) * 3;
                    this.y += Math.sin(moveAngle) * 3;
                    this.angle = moveAngle;
                }
                
                this.turretAngle = Math.atan2(mouse.y - this.y, mouse.x - this.x);

                if (mouse.down && Date.now() - this.lastShot > 500) {
                    this.shoot();
                    this.lastShot = Date.now();
                }

                // Wall collision
                this.game.walls.forEach(wall => {
                    if (this.x < wall.x + wall.w && this.x + this.size > wall.x && this.y < wall.y + wall.h && this.y + this.size > wall.y) {
                        this.x -= Math.cos(this.angle) * 3;
                        this.y -= Math.sin(this.angle) * 3;
                    }
                });
            }
            
            async shoot() {
                const bulletId = doc(collection(db, "dummy")).id; // Generate a unique ID
                const bullet = {
                    id: bulletId,
                    owner: this.game.playerNumber === 1 ? 'p1' : 'p2',
                    x: this.x + this.size / 2 + Math.cos(this.turretAngle) * this.turretLength,
                    y: this.y + this.size / 2 + Math.sin(this.turretAngle) * this.turretLength,
                    vx: Math.cos(this.turretAngle) * 10,
                    vy: Math.sin(this.turretAngle) * 10,
                    size: 8,
                    life: 100
                };
                await updateDoc(doc(db, "tank-games", this.game.currentGameId), {
                    [`bullets.${bulletId}`]: bullet
                });
            }

            draw(ctx) {
                // Body
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.uid === this.game.tanks.p1.uid ? '#4ddbff' : '#ff9933';
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
                
                // Turret
                ctx.save();
                ctx.translate(this.x + this.size/2, this.y + this.size/2);
                ctx.rotate(this.turretAngle);
                ctx.fillStyle = '#999';
                ctx.fillRect(0, -5, this.turretLength, 10);
                ctx.restore();
                
                // Username
                ctx.fillStyle = '#FFF'; ctx.font = '14px Orbitron'; ctx.textAlign = 'center';
                ctx.fillText(this.username, this.x + this.size/2, this.y - 20);

                // Health bar
                ctx.fillStyle = '#222'; ctx.fillRect(this.x, this.y - 10, this.size, 5);
                ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 10, this.size * (this.health/100), 5);
            }
        }
        
        window.game = new Game();
    </script>
</body>
</html>
